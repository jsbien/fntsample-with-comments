/*
 * ucdXmlReader.c
 *
 * Author: Paweł Parafiński <ppablo28@gmail.com>
 *
 * This file is used to translate the structure (created by libxml) of an XML file with UCD data
 * to much more convenient form.
 * This XML file is generated by my parser (available at https://github.com/ppablo28/ucd_xml_parser).
 */

#include "ucd_xml_reader.h"

#include <string.h>
#include <ctype.h>

const struct XmlTag xmlTags = { "comment_line", "subtitle", "title", "file_comment",
    "notice_line", "char_entry", "formalalias_line", "block_header", "block_subheader",
    "variation_line", "decomposition", "compat_mapping", "alias_line", "ucd", "cross_ref" };

const struct XmlAttr xmlAttrs = { "compat", "block_end", "name", "with_asterisk", "type",
    "code_point", "block_start", "variation", "content", "ref", "decomp" };

const struct YesNo yesNoValues = { "Y", "N" };

/* Trim whitespaces */
char *trimWhitespace(char *str) {
  char *p = str;
  size_t l = strlen(p);

  while (isspace(p[l - 1])) {
    p[--l] = 0;
  }
  while (*p && isspace(*p)) {
    ++p, --l;
  }

  memmove(str, p, l + 1);
  return str;
}

/* Return new allocated string with the given content */
char *allocateString(const xmlChar *str) {
  return strdup((char *) str);
}

/* Create empty structures defined in the header file */
static struct header_block *emptyHeaderBlock(void) {
  struct header_block *headBck = malloc(sizeof(*headBck));
  headBck->outer_tags = NULL;
  headBck->chars = NULL;
  headBck->subheaders = NULL;
  headBck->name = NULL;
  headBck->next = NULL;
  headBck->start = 0L;
  headBck->end = 0L;
  return headBck;
}

static struct subheader_block *emptySubHeaderBlock(void) {
  struct subheader_block *subBck = malloc(sizeof(*subBck));
  subBck->start = -1UL;
  subBck->end = -1UL;
  subBck->name = NULL;
  subBck->outer_tags = NULL;
  subBck->chars = NULL;
  subBck->next = NULL;
  return subBck;
}

static struct tag_attr *emptyTagAttr(void) {
  struct tag_attr *tagAttr = malloc(sizeof(*tagAttr));
  tagAttr->name = NULL;
  tagAttr->value = NULL;
  tagAttr->next = NULL;
  return tagAttr;
}

static struct simple_tag *emptySimpleTag(void) {
  struct simple_tag *smplTag = malloc(sizeof(*smplTag));
  smplTag->name = NULL;
  smplTag->content = NULL;
  smplTag->info = NULL;
  smplTag->next = NULL;
  return smplTag;
}

static struct char_entry *emptyCharEntry(void) {
  struct char_entry *entry = malloc(sizeof(*entry));
  entry->name = NULL;
  entry->type = NULL;
  entry->cp = 0L;
  entry->char_info = NULL;
  entry->next = NULL;
  return entry;
}

/* Parse an XML tag to the structure */
static void parseSimpleTag(struct simple_tag *simpleTag, xmlNode *node, const char *tag,
    const char *attr) {
  struct tag_attr *tagAttr;
  struct tag_attr *prevTagAttr = NULL;
  xmlAttr *attrs;
  /* Tag name */
  simpleTag->name = tag;

  /* If notice line, handle it separately */
  if (strcmp(tag, xmlTags.NOTICE_LINE) == 0) {
    simpleTag->content = trimWhitespace(allocateString(xmlNodeGetContent(node)));
    if (simpleTag->content == NULL)
      printf("Error in copying a notice line tag\n");
  }

  /* Parse content */
  for (attrs = node->properties; attrs; attrs = attrs->next) {
    if (attrs->type != XML_ATTRIBUTE_NODE) {
      continue;
    }

    if (attr && strcmp((const char *) attrs->name, attr) == 0) {
      simpleTag->content = allocateString(attrs->children->content);
      if (simpleTag->content == NULL)
        printf("Error in copying a simple tag\n");
    }
    else {
      tagAttr = emptyTagAttr();

      /* Connect previous attribute */
      if (prevTagAttr != NULL) {
        prevTagAttr->next = tagAttr;
      }
      prevTagAttr = tagAttr;

      /* Add the first info */
      if (simpleTag->info == NULL) {
        simpleTag->info = tagAttr;
      }

      /* Parse tag's additional attribute - name */
      tagAttr->name = allocateString(attrs->name);
      if (tagAttr->name == NULL)
        printf("Error in copying a simple tag attr name\n");

      /* Parse tag's additional attribute - value */
      tagAttr->value = allocateString(attrs->children->content);
      if (tagAttr->value == NULL)
        printf("Error in copying a simple tag attr value\n");
    }
  }
}

/* Parse char entry and its whole content */
static void parseCharEntry(struct char_entry *entry, xmlNode *charNode) {
  xmlNode *node = NULL;
  xmlAttr *attrs = NULL;

  /* Simple tag pointers */
  struct simple_tag* currSmpl = NULL;
  struct simple_tag* prevSmpl = NULL;

  /* Get attributes of the char entry */
  for (attrs = charNode->properties; attrs; attrs = attrs->next) {
    if (attrs->type != XML_ATTRIBUTE_NODE) {
      continue;
    }

    if (strcmp((const char *) attrs->name, xmlAttrs.NAME) == 0) {
      entry->name = allocateString(attrs->children->content);
      if (entry->name == NULL) {
        printf("Error in copying char entry name\n");
      }
    }
    else if (strcmp((const char *) attrs->name, xmlAttrs.TYPE) == 0) {
      entry->type = allocateString(attrs->children->content);
      if (entry->type == NULL) {
        printf("Error in copying char entry type\n");
      }
    }
    else if (strcmp((const char *) attrs->name, xmlAttrs.CODE_POINT) == 0) {
      if (sscanf((const char *) attrs->children->content, "%lX", &entry->cp) != 1) {
        printf("Parse error in char entry code point\n");
      }
    }
  }

  /* Iterate through the char entry children */
  for (node = charNode->children; node; node = node->next) {
    /* Continue only with a node */
    if (node->type != XML_ELEMENT_NODE) {
      continue;
    }

    currSmpl = emptySimpleTag();

    /* Connect new simple tag with the previous one */
    if (prevSmpl != NULL) {
      prevSmpl->next = currSmpl;
    }
    prevSmpl = currSmpl;

    /* Assign the first simple tag */
    if (entry->char_info == NULL) {
      entry->char_info = currSmpl;
    }

    if (strcmp((const char *) node->name, xmlTags.NOTICE_LINE) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.NOTICE_LINE, NULL);
    }
    else if (strcmp((const char *) node->name, xmlTags.CROSS_REF) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.CROSS_REF, xmlAttrs.REF);
    }
    else if (strcmp((const char *) node->name, xmlTags.ALIAS_LINE) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.ALIAS_LINE, xmlAttrs.NAME);
    }
    else if (strcmp((const char *) node->name, xmlTags.FORMALALIAS_LINE) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.FORMALALIAS_LINE, xmlAttrs.NAME);
    }
    else if (strcmp((const char *) node->name, xmlTags.VARIATION_LINE) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.VARIATION_LINE, xmlAttrs.VARIATION);
    }
    else if (strcmp((const char *) node->name, xmlTags.DECOMPOSITION) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.DECOMPOSITION, xmlAttrs.DECOMP);
    }
    else if (strcmp((const char *) node->name, xmlTags.COMPAT_MAPPING) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.COMPAT_MAPPING, xmlAttrs.COMPAT);
    }
    else if (strcmp((const char *) node->name, xmlTags.COMMENT_LINE) == 0) {
      parseSimpleTag(currSmpl, node, xmlTags.COMMENT_LINE, xmlAttrs.CONTENT);
    }

  } /* end for */
}

/* Parse the content of a subheader block */
static void parseSubHeaderContent(xmlNode *content, struct subheader_block *block) {
  xmlNode *node = NULL;

  /* Simple tags pointers */
  struct simple_tag* currSmpl = NULL;
  struct simple_tag* prevSmpl = NULL;

  /* Char entries pointers */
  struct char_entry* currChar = NULL;
  struct char_entry* prevChar = NULL;

  /* Iterate through block subheader children */
  for (node = content; node; node = node->next) {
    /* Continue only with a node */
    if (node->type != XML_ELEMENT_NODE) {
      continue;
    }

    if (strcmp((const char *) node->name, xmlTags.CHAR_ENTRY) == 0) {
      currChar = emptyCharEntry();

      /* Connect new char entry with the previous one */
      if (prevChar != NULL) {
        prevChar->next = currChar;
      }
      prevChar = currChar;

      /* Assign the first char entry */
      if (block->chars == NULL) {
        block->chars = currChar;
      }

      parseCharEntry(currChar, node);

      /* Update the first and the last char indicators */
      if (block->start == -1UL) {
        block->start = currChar->cp;
      }
      block->end = currChar->cp;
    }
    else {
      currSmpl = emptySimpleTag();

      /* Connect new simple tag with the previous one */
      if (prevSmpl != NULL) {
        prevSmpl->next = currSmpl;
      }
      prevSmpl = currSmpl;

      /* Assign the first simple tag */
      if (block->outer_tags == NULL) {
        block->outer_tags = currSmpl;
      }

      if (strcmp((const char *) node->name, xmlTags.NOTICE_LINE) == 0) {
        parseSimpleTag(currSmpl, node, xmlTags.NOTICE_LINE, NULL);
      }
      else if (strcmp((const char *) node->name, xmlTags.CROSS_REF) == 0) {
        parseSimpleTag(currSmpl, node, xmlTags.CROSS_REF, xmlAttrs.REF);
      }
      else if (strcmp((const char *) node->name, xmlTags.COMMENT_LINE) == 0) {
        parseSimpleTag(currSmpl, node, xmlTags.COMMENT_LINE, xmlAttrs.CONTENT);
      }

    } /* end else */
  } /* end for */
}

/* Parse the content of a header block */
static void parseBlockHeaderContent(xmlNode *block_content, struct header_block *block) {
  xmlNode *node = NULL;
  xmlAttr *attrs = NULL;

  /* Subheader pointers */
  struct subheader_block* blockSub = NULL;
  struct subheader_block* prevSub = NULL;

  /* Simple tags pointers */
  struct simple_tag* currSmpl = NULL;
  struct simple_tag* prevSmpl = NULL;

  /* Char entries pointers */
  struct char_entry* currChar = NULL;
  struct char_entry* prevChar = NULL;

  /* Iterate through block header children */
  for (node = block_content; node; node = node->next) {
    /* Continue only with a node */
    if (node->type != XML_ELEMENT_NODE) {
      continue;
    }

    if (strcmp((const char *) node->name, xmlTags.BLOCK_SUBHEADER) == 0) {
      blockSub = emptySubHeaderBlock();

      /* Connect new block subheader with the previous one */
      if (prevSub != NULL) {
        prevSub->next = blockSub;
      }
      prevSub = blockSub;

      /* Assign the first subheader block */
      if (block->subheaders == NULL) {
        block->subheaders = blockSub;
      }

      /* Get attributes of the block subheader */
      for (attrs = node->properties; attrs; attrs = attrs->next) {
        if (attrs->type == XML_ATTRIBUTE_NODE && strcmp((const char *) attrs->name, xmlAttrs.NAME) == 0) {
          blockSub->name = allocateString(attrs->children->content);
          if (blockSub->name == NULL) {
            printf("Error in copying block subheader name\n");
          }
        }
      }

      /* Parse subheader content */
      parseSubHeaderContent(node->children, blockSub);
    }
    else if (strcmp((const char *) node->name, xmlTags.CHAR_ENTRY) == 0) {
      currChar = emptyCharEntry();

      /* Connect new char entry with the previous one */
      if (prevChar != NULL) {
        prevChar->next = currChar;
      }
      prevChar = currChar;

      /* Assign the first char entry */
      if (block->chars == NULL) {
        block->chars = currChar;
      }

      parseCharEntry(currChar, node);
    }
    else {
      currSmpl = emptySimpleTag();

      /* Connect new simple tag with the previous one */
      if (prevSmpl != NULL) {
        prevSmpl->next = currSmpl;
      }
      prevSmpl = currSmpl;

      /* Assign the first simple tag */
      if (block->outer_tags == NULL) {
        block->outer_tags = currSmpl;
      }

      if (strcmp((const char *) node->name, xmlTags.NOTICE_LINE) == 0) {
        parseSimpleTag(currSmpl, node, xmlTags.NOTICE_LINE, NULL);
      }
      else if (strcmp((const char *) node->name, xmlTags.CROSS_REF) == 0) {
        parseSimpleTag(currSmpl, node, xmlTags.CROSS_REF, xmlAttrs.REF);
      }
      else if (strcmp((const char *) node->name, xmlTags.COMMENT_LINE) == 0) {
        parseSimpleTag(currSmpl, node, xmlTags.COMMENT_LINE, xmlAttrs.CONTENT);
      }

    } /* end else */
  } /* end for */
}

/*
 * Create a convenient representation of the XML file. Put all blocks into the list,
 * assign character entries and other useful information to them.
 */
struct header_block *parse_ucd_from_xml(const xmlNode *rootChildren) {
  if (rootChildren != NULL) {
    const xmlNode *node = NULL;
    xmlAttr *attrs = NULL;
    struct header_block* firstBlock = NULL;
    struct header_block* blockHead = NULL;
    struct header_block* prevBlock = NULL;

    /* Iterate through root children and ignore all tags except for block headers */
    for (node = rootChildren; node; node = node->next) {
      if (node->type == XML_ELEMENT_NODE && strcmp((const char *) node->name, xmlTags.BLOCK_HEADER) == 0) {
        blockHead = emptyHeaderBlock();

        /* Connect new block with the previous one */
        if (prevBlock != NULL) {
          prevBlock->next = blockHead;
        }
        prevBlock = blockHead;

        /* Assign the first block */
        if (firstBlock == NULL) {
          firstBlock = blockHead;
        }

        /* Get attributes of the block header */
        for (attrs = node->properties; attrs; attrs = attrs->next) {
          /* Continue only with an attribute */
          if (attrs->type != XML_ATTRIBUTE_NODE) {
            continue;
          }

          if (strcmp((const char *) attrs->name, xmlAttrs.BLOCK_START) == 0) {
            if (sscanf((const char *) attrs->children->content, "%lX", &blockHead->start) != 1) {
              printf("Parse error in block header start\n");
            }
          }
          else if (strcmp((const char *) attrs->name, xmlAttrs.BLOCK_END) == 0) {
            if (sscanf((const char *) attrs->children->content, "%lX", &blockHead->end) != 1) {
              printf("Parse error in block header end\n");
            }
          }
          else if (strcmp((const char *) attrs->name, xmlAttrs.NAME) == 0) {
            blockHead->name = allocateString(attrs->children->content);
            if (blockHead->name == NULL) {
              printf("Error in copying block header name\n");
            }
          }
        }

        parseBlockHeaderContent(node->children, blockHead);
      }
    }

    return firstBlock;
  }

  return NULL;
}

/* Find the block header with the given character code */
const struct header_block* find_ucd_block(const struct header_block* firstBlock,
    const unsigned long cp) {
  const struct header_block *block;

  for (block = firstBlock; block; block = block->next) {
    if ((cp >= block->start) && (cp <= block->end))
      return block;
  }
  return NULL;
}

